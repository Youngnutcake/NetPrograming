# 网络编程之 `socket` 心跳
## 回顾
> 在[上一例子](https://github.com/shenyuanluo/NetPrograming/tree/master/TCPDemo/TCPDemo_02)已经了解了 TCP 客户端与服务端相互通信；但是在通信过程中，怎么知道对方已经掉线了呢？这就需要**心跳机制**。
> 
> 心跳，就是每每隔一定时间间隔，给对方发送个消息，让对方知道自己还活着，以确保连接的有效性。心跳的发送方可以是服务端，也可以是客户端；不过比较起来，前者开销就比较大。

本例子由客户端给服务器发送心跳包，基本流程思路：

1. 如果服务端接收到的是心跳包，将该客户端对应的心跳检查计数器 `count` 清零；
2. 在心跳检查线程中，每隔一定时间（假定：10秒）遍历所有已连接的客户端的心跳检查计数器 `count`：
	- 若 `count` 小于 一定的检查次数（假定：6次），将 count 计数器加 1；
	- 若 `count` 大于等于设定的检查次数（假定：6次），说明已经（超过 1分钟 ）未收到该用户心跳包，则判定该用户已经掉线；
3. 客户端则建立心跳发送线程，定时（假定：10秒）给服务器发送心跳包。


# 相关函数
## fd_set
> `struct fd_set` 可以理解为一个集合，这个集合中存放的是**文件描述符(filedescriptor)**，即文件句柄。Unix下任何设备、管道、FIFO等都是文件形式，所以 `socket` 就是一个文件，socket句柄就是一个文件描述符。fd_set 相关操作如下：

1. **FD_ZERO：**清空集合。
2. **FD_SET：**将一个给定的文件描述符加入集合之中。
3. **FD_CLR：**将一个给定的文件描述符从集合中删除。
4. **FD_ISSET：**检查集合中指定的文件描述符是否可以读写。

## timeval
> 用来代表时间值，有两个成员。

1. **tv_sec：**秒数。
2. **tv_usec：**毫秒数。

## select
1. **原型：**

	``` C
	int select(int maxfdp, fd_set *readfds, fd_set *writefds, fd_set *errorfds, struct timeval *timeout); 
	```
2. **参数：**
	- **maxfdp：**是指集合中所有文件描述符的范围，即所有文件描述符的**最大值加1**。
	- **readfds：**是指向 `fd_set` 结构的指针，这个集合中应该包括文件描述符，要监视这些文件描述符的**读变化**的；如果这个集合中有一个文件可读，select就会返回一个大于0的值，表示有文件可读，如果没有可读的文件，则根据timeout参数再判断是否超时，若超出timeout的时间，select返回0，若发生错误返回负值。可以传入NULL值，表示不关心任何文件的读变化。
	- **writefds：**是指向 `fd_set` 结构的指针，这个集合中应该包括文件描述符，要监视这些文件描述符的**写变化**的；如果这个集合中有一个文件可写，select就会返回一个大于0的值，表示有文件可写，如果没有可写的文件，则根据timeout参数再判断是否超时，若超出timeout的时间，select返回0，若发生错误返回负值。可以传入NULL值，表示不关心任何文件的写变化。
	- **errorfds：**同上面两个参数的意图，用来监视文件错误异常。
	- **timeout：**是 `select` 的超时时间，这个参数至关重要，它可以使select处于三种状态，第一，若将NULL以形参传入，即不传入时间结构，就是将select置于阻塞状态，一定等到监视文件描述符集合中某个文件描述符发生变化为止；第二，若将时间值设为0秒0毫秒，就变成一个纯粹的非阻塞函数，不管文件描述符是否有变化，都立刻返回继续执行，文件无变化返回0，有变化返回一个正值；第三，timeout的值大于0，这就是等待的超时时间，即select在timeout时间内阻塞，超时时间之内有事件到来就返回了，否则在超时后不管怎样一定返回，返回值同上述。 
3. **返回值：**返回状态发生变化的描述符总数。
	- **负值：**select错误。
	- **正值：**某些文件可读写或出错。
	- **0：**等待超时，没有可读写或错误的文件。